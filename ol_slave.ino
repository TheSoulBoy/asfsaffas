#include <Wire.h>
#include <Adafruit_SSD1306.h>
#include <Fonts/FreeMono9pt7b.h>

static const uint_least8_t PROGMEM yeti[] =
{ 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xFF, 0xFE, 0x00, 0x00, 0x01, 0x80, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x07,
  0xFF, 0xFE, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x07, 0xFF, 0xFF, 0xF0, 0x00, 0x07, 0xE0, 0x00, 0x07,
  0xFF, 0xFF, 0xF0, 0x00, 0x07, 0xFF, 0xF0, 0x07, 0xFF, 0xFF, 0xFE, 0x00, 0x07, 0xFF, 0xFE, 0x07,
  0xFF, 0xFF, 0xFF, 0x00, 0x03, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0x80, 0x03, 0xFF, 0xFF, 0xC7,
  0xFF, 0xFF, 0xFF, 0xC0, 0x0F, 0xFF, 0xFF, 0xC7, 0xFF, 0xFF, 0xFF, 0xC0, 0x0F, 0xFF, 0xFF, 0xE7,
  0xFF, 0xFF, 0xFF, 0xE0, 0x0F, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xE0, 0x0F, 0xFF, 0xE1, 0xE7,
  0xFF, 0xFF, 0xFF, 0xE0, 0x0F, 0xFF, 0xE1, 0xE7, 0xFF, 0xFF, 0xFF, 0xC0, 0x3F, 0x7F, 0xE0, 0xF7,
  0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x3F, 0xE0, 0xF7, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x1F, 0xF1, 0xF7,
  0xFF, 0xFF, 0xFF, 0x80, 0x3C, 0x1F, 0xF1, 0x77, 0xFF, 0xFF, 0xFF, 0x80, 0x3C, 0x3F, 0xF0, 0x77,
  0xFF, 0xFF, 0xFF, 0xFC, 0x3E, 0x7F, 0xF0, 0x77, 0xFF, 0xFF, 0xFF, 0xFE, 0x3E, 0xFF, 0xFF, 0x77,
  0xFF, 0xFF, 0xFF, 0xFE, 0x3E, 0xFF, 0xFF, 0x37, 0xFF, 0xFF, 0xFF, 0xFE, 0x38, 0xFE, 0xFF, 0x87,
  0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x78, 0x3F, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x7C, 0x07, 0xE7,
  0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x3E, 0x01, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x3E, 0x01, 0xC7,
  0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x7E, 0x1F, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xFF, 0x0F, 0x87,
  0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0x37, 0x19, 0x9B, 0x10, 0x63, 0x8E, 0xFB,
  0xCB, 0x36, 0xED, 0x9A, 0x5D, 0xDD, 0xB6, 0x73, 0xCF, 0x14, 0xE5, 0x9A, 0x7D, 0xDD, 0xB6, 0x73,
  0xE3, 0x54, 0xE5, 0x13, 0x1D, 0x9C, 0x8E, 0xAB, 0xFB, 0x44, 0xE4, 0x47, 0xDD, 0xDD, 0xAE, 0xAB,
  0xDB, 0x66, 0xEE, 0x66, 0xDD, 0xDD, 0xB6, 0xDB, 0xC3, 0x77, 0x1E, 0xEE, 0x1D, 0xE3, 0xB6, 0xDB,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Slave Flags
#define RESET 0
#define DISPLAY (1 << 0)          // 0000 0001
#define FORCE_DISPLAY (1 << 1)    // 0000 0010
#define AZIMUTH (1 << 2)          // 0000 0100
#define TEMPERATURE (1 << 3)      // 0000 1000

Adafruit_SSD1306 display;

boolean displayed = false;    // has display been already refreshed

uint_least8_t graphY[128];

float currentTemp = -420.0f;


void setup()
{
  Serial.begin(9600);

  // Start the I2C Bus as Slave on address 2
  Wire.begin(2); 
  // Attach a function to trigger when something is received.
  Wire.onReceive(receiveEvent);

  DisplayInit();
}


void loop()
{
}


void receiveEvent(int bytes)
{
  uint_least8_t orders = Wire.read();    // read one byte from the I2C

  if (orders & DISPLAY)
  {
    // shootCnt
    uint_least8_t mode = Wire.read();
    ShootAndModeDraw(0, mode);
    displayed = true;
  }
  if (orders & FORCE_DISPLAY)
  {
    
    displayed = true;
  }
  if (orders & AZIMUTH)
  {
    uint_least8_t azim = Wire.read();
    GraphUpdateAndDraw(azim);
  }
  if (orders & TEMPERATURE)
  {
    float c = Wire.read();
    currentTemp = (c << 8) | (Wire.read());
  }
  if (orders == RESET)
  {
    displayed = false;
  }
}


void DisplayInit()
{
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);

  display.clearDisplay();
  display.setTextColor(WHITE);
  display.setRotation(0);
  display.setTextWrap(false);
  display.dim(0);

  // miniature bitmap display
  display.drawBitmap(0, 0, yeti, 64, 60, WHITE);
  display.display();

  for(uint_least8_t xval = 0; xval <= 124; xval++)
  {
    uint_least8_t y = 63;
    display.drawPixel((int)xval, (int)y, WHITE);
    display.drawPixel((int)xval, (int)y - 1, WHITE);
    display.display();
    delay(1);
  }
}


void GraphUpdateAndDraw(uint_least8_t &yPos)
{
  for (uint_least8_t i = 0; i < 127; i++)
  {
    graphY[(int16_t)i] = graphY[(int16_t)i + 1];

    display.drawPixel((int16_t)i, 
      64 - (int16_t)graphY[i] * 32 / 360, 
      WHITE);
  }

  graphY[127] = yPos;
  
  display.drawPixel((int16_t)127, 
      64 - (int16_t)graphY[127] * 32 / 360, 
      WHITE);
}


void ShootAndModeDraw(unsigned int &shCnt, uint_least8_t &mode)
{
  char string[10];
  dtostrf(shCnt, 3, 0, string);
  display.clearDisplay();
  display.setFont(&FreeMono9pt7b);
  display.setTextSize(0);

  // Print shooting mode
  display.setCursor(0, 10);
  display.println(
    mode == 0 ? "Safe" :
    mode == 1 ? "Semi" :
    mode == 2 ? "Auto" :
    mode == 3 ? "Burst" :
    mode == 4 ? "Rhythmic" : mode);

  display.setFont(&FreeMono9pt7b);  // Set a custom font
  
  // Print variable with left alignment:
  display.setCursor(64, 10);
  display.println(shCnt);
      
  display.setCursor(0, 30);
  display.println(currentTemp);

  display.display();
  displayed = true;
}